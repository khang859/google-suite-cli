---
phase: 02-core-read-operations
plan: 01
type: execute
depends_on: []
files_modified: [cmd/messages.go]
---

<objective>
Implement messages list and get commands for reading Gmail messages.

Purpose: Enable users to list messages in their inbox and read individual message content.
Output: Working `gsuite messages list` and `gsuite messages get` commands.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@internal/auth/auth.go
@cmd/whoami.go
@cmd/root.go

**Tech stack available:** Go, Cobra CLI, google.golang.org/api/gmail/v1
**Established patterns:** Cobra command in cmd/, auth via auth.NewGmailService(), getter functions from root.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create messages command with list and get subcommands</name>
  <files>cmd/messages.go</files>
  <action>
Create cmd/messages.go with:

1. Parent `messagesCmd` cobra command at "messages" for grouping
2. `messagesListCmd` subcommand at "list":
   - Get credentials and user from root flags (same pattern as whoami.go)
   - Create Gmail service via auth.NewGmailService()
   - Call service.Users.Messages.List("me") with optional flags:
     - --max-results/-n (default 10, max 500)
     - --label-ids (comma-separated, e.g., "INBOX,UNREAD")
     - --query/-q (Gmail search query string)
   - Print message ID, thread ID, and snippet for each result
   - Handle pagination token in output (show "More results available" if NextPageToken exists)

3. `messagesGetCmd` subcommand at "get":
   - Require message ID as positional arg
   - Get credentials and user from root flags
   - Create Gmail service
   - Call service.Users.Messages.Get("me", messageID).Format("full").Do()
   - Print: From, To, Subject, Date headers, and body (prefer text/plain, fallback to snippet)
   - Decode base64url encoded body content

Use same error handling pattern as whoami.go (missing user, missing credentials, API errors).
Register all commands in init().
  </action>
  <verify>
go build -o gsuite . && ./gsuite messages --help && ./gsuite messages list --help && ./gsuite messages get --help && go vet ./...
  </verify>
  <done>
- `gsuite messages list` shows help with --max-results, --label-ids, --query flags
- `gsuite messages get` shows help requiring message ID argument
- `go vet ./...` passes
- Binary builds without errors
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build -o gsuite .` succeeds
- [ ] `./gsuite messages --help` shows subcommands (list, get)
- [ ] `./gsuite messages list --help` shows flags
- [ ] `./gsuite messages get --help` shows usage with message ID
- [ ] `go vet ./...` passes
</verification>

<success_criteria>

- Messages list command implemented with filtering flags
- Messages get command implemented with full message display
- Same auth pattern as existing commands
- No build or vet errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-read-operations/02-01-SUMMARY.md`
</output>
