---
phase: 04-polish
plan: 01
type: execute
depends_on: []
files_modified: [cmd/messages.go, cmd/send.go, cmd/drafts.go]
---

<objective>
Add attachment support: display attachment info when viewing messages, download attachments by ID, and send messages with file attachments.

Purpose: Complete Gmail API coverage for file handling â€” the last major capability gap.
Output: Working attachment download and send-with-attachment commands.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@cmd/messages.go
@cmd/send.go
@cmd/drafts.go
@cmd/root.go
@internal/auth/auth.go

**Tech stack:** Go, Cobra CLI, google.golang.org/api/gmail/v1
**Established patterns:**
- Auth boilerplate: GetCredentialsFile(), GetUserEmail(), auth.Config{}, auth.NewGmailService()
- base64url encoding/decoding for message bodies
- MIME part traversal for multipart messages (extractBody, findPlainTextPart)
- Cobra flag patterns (StringVarP, Int64VarP, MarkFlagRequired)
- Error message style: "Gmail API error: %w", "authentication failed: %w"
</context>

<tasks>

<task type="auto">
  <name>Task 1: Show attachments in messages get and add attachment download</name>
  <files>cmd/messages.go</files>
  <action>
Two changes to cmd/messages.go:

1. **Show attachment info in `messages get`**: After printing headers and body in runMessagesGet, iterate msg.Payload.Parts (recursively) looking for parts with a non-empty Filename field. For each attachment, print:
   ```
   Attachment: <filename> (<mimeType>, <size> bytes, ID: <attachmentId>)
   ```
   Use a helper function `findAttachments(parts []*gmail.MessagePart) []attachmentInfo` that returns a slice of structs with Filename, MimeType, Size (from part.Body.Size), AttachmentId (from part.Body.AttachmentId). Recurse into nested parts.

2. **Add `messages get-attachment` subcommand**: New command `messages get-attachment <message-id> <attachment-id>` with flags:
   - `--output/-o` (string): Output file path (defaults to attachment filename from API)
   - Flow: Call `service.Users.Messages.Attachments.Get("me", messageID, attachmentID).Do()` to get the attachment body data (base64url encoded). Decode with base64.URLEncoding (try RawURLEncoding as fallback like existing decodeBase64URL pattern). Write decoded bytes to output file using os.WriteFile with 0644 permissions.
   - If --output not specified, get the filename by fetching the message with `service.Users.Messages.Get("me", messageID).Format("full").Do()` and searching parts for matching attachmentId. If not found, use "attachment_<attachmentId>" as fallback filename.
   - Print: "Attachment saved: <filepath> (<size> bytes)"

Register the new subcommand in init() alongside messagesGetCmd.

Add necessary imports: "os", "path/filepath" (only if needed for the output path).
  </action>
  <verify>go build ./... succeeds without errors. `gsuite messages get-attachment --help` shows usage with --output flag.</verify>
  <done>Messages get shows attachment info for messages with attachments. get-attachment subcommand downloads attachment to file.</done>
</task>

<task type="auto">
  <name>Task 2: Add --attach flag to send command for file attachments</name>
  <files>cmd/send.go</files>
  <action>
Add file attachment support to the `send` command:

1. Add flag `--attach/-a` (string, repeatable via StringArrayVarP) for file paths to attach. Register in init().

2. Modify `runSend`: If attachments provided, switch from simple RFC 2822 to MIME multipart message:
   - Use `mime/multipart` writer with `\r\n` line endings
   - Create a mixed boundary: `multipart.NewWriter(buffer)`
   - Write headers: To, Cc, Bcc, Subject, MIME-Version: 1.0, Content-Type: multipart/mixed; boundary=...
   - First part: text/plain body content
   - For each attachment file:
     - Read file with os.ReadFile
     - Determine MIME type with `net/http.DetectContentType(fileData[:512])` (cap at 512 bytes or file length)
     - Create part with headers: Content-Type, Content-Disposition: attachment; filename="<basename>", Content-Transfer-Encoding: base64
     - Write base64-encoded file data (use base64.StdEncoding, line-wrap at 76 chars)
   - Close multipart writer
   - Base64url encode the entire message for Gmail API Raw field
   - If no attachments, use existing buildSendRFC2822Message (no behavior change for simple sends)

3. Add necessary imports: "mime/multipart", "net/http", "os", "path/filepath", "bytes"

Validate each attachment file exists before building message (return error "attachment file not found: <path>" if os.Stat fails).
  </action>
  <verify>go build ./... succeeds. `gsuite send --help` shows --attach/-a flag. Existing send without --attach still works (no behavior change).</verify>
  <done>Send command accepts --attach flag for file attachments. MIME multipart message correctly constructed. Simple sends unchanged.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go vet ./...` passes
- [ ] `gsuite messages get --help` shows usage
- [ ] `gsuite messages get-attachment --help` shows --output flag
- [ ] `gsuite send --help` shows --attach flag
- [ ] No new lint warnings or errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Attachment info displayed when viewing messages with attachments
- get-attachment downloads and saves attachment files
- send --attach constructs valid MIME multipart messages
- Existing commands unchanged (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/04-polish/04-01-SUMMARY.md`
</output>
