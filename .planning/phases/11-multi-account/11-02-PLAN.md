---
phase: 11-multi-account
plan: 02
type: execute
depends_on: [11-01]
files_modified: [internal/auth/migrate.go, internal/auth/auth.go]
---

<objective>
Add migration logic from single-token to multi-account storage, and update the core auth API (Login, NewGmailService) to work with the account store.

Purpose: Make the auth layer multi-account aware while auto-migrating existing single-account users.
Output: Transparent migration on first run, Login() that adds accounts to the store, NewGmailService() that resolves the correct account.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v3.0-ROADMAP.md
@.planning/phases/11-multi-account/11-01-PLAN.md
@internal/auth/auth.go
@internal/auth/token.go

**Tech stack available:** Go, Cobra, OAuth2 PKCE, Gmail API
**Established patterns:** NewGmailService(ctx) returns authenticated service, Login(ctx, credJSON) returns email
**Constraining decisions:**
- Plan 11-01: AccountStore and per-account token functions exist
- Legacy token.json must be migrated transparently
- Email is discovered after OAuth2 login (profile API call)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration logic</name>
  <files>internal/auth/migrate.go</files>
  <action>
Create `internal/auth/migrate.go` with:

**Function:** `MigrateIfNeeded(ctx context.Context, credJSON []byte) error`

Logic:
1. Check if `accounts.json` exists (via LoadAccountStore — returns empty store if missing)
2. If store has accounts, migration already done — return nil
3. Check if legacy `token.json` exists (via LegacyTokenPath + os.Stat)
4. If no legacy token, no migration needed — return nil
5. Load legacy token via LoadLegacyToken()
6. Create a temporary Gmail service from the legacy token to discover the email:
   - Extract OAuth2 client creds from credJSON
   - Create OAuth2Config, call NewGmailService with the token
   - Call Users.GetProfile("me") to get email
7. Save token to per-account path: SaveTokenFor(email, token)
8. Create account store with this account as active: store.AddAccount(email), store.Save()
9. Rename legacy token.json to token.json.bak (os.Rename)
10. Return nil

If any step fails, return error but don't leave partial state — the next run will retry.

**Function:** `EnsureMigrated(ctx context.Context) error`
- Convenience wrapper: loads credentials via LoadCredentials(), then calls MigrateIfNeeded
- If LoadCredentials fails (no creds set), skip migration silently (user hasn't set up yet)
  </action>
  <verify>go build -o gsuite . compiles without errors</verify>
  <done>migrate.go created with MigrateIfNeeded and EnsureMigrated. Legacy token.json is transparently migrated to tokens/<email>.json + accounts.json on first run.</done>
</task>

<task type="auto">
  <name>Task 2: Update Login() for multi-account</name>
  <files>internal/auth/auth.go</files>
  <action>
Modify `Login()` in auth.go:

Current signature: `func Login(ctx context.Context, credJSON []byte) (string, error)`
Keep the same signature — it still returns the email.

Change the internal flow:
1. Extract client creds, create OAuth2Config, run Authenticate() — same as before
2. Create Gmail service from token, get profile email — same as before
3. **NEW**: Save token to per-account path: `SaveTokenFor(email, token)` (instead of `SaveToken(token)`)
4. **NEW**: Load account store, add/update account, save: `store.AddAccount(email)`, `store.Save()`
5. Return email

Remove the call to `SaveToken(token)` (the old single-file save).
  </action>
  <verify>go build -o gsuite . compiles without errors</verify>
  <done>Login() saves tokens per-account and updates AccountStore. Old SaveToken call removed.</done>
</task>

<task type="auto">
  <name>Task 3: Update NewGmailService() for multi-account</name>
  <files>internal/auth/auth.go</files>
  <action>
Modify `NewGmailService()` in auth.go:

Change signature: `func NewGmailService(ctx context.Context) (*gmail.Service, error)`
New signature: `func NewGmailService(ctx context.Context, account string) (*gmail.Service, error)`

The `account` parameter is the email to use. If empty string, resolve from the account store.

New logic:
1. Load credentials (same as before)
2. Extract client creds (same as before)
3. **NEW**: Run EnsureMigrated(ctx) to handle legacy token migration
4. **NEW**: Resolve account email:
   - If `account != ""`, use it directly
   - Otherwise, load AccountStore and call GetActive()
   - If no accounts found, return error: "no authenticated accounts. Run 'gsuite login' first"
5. **NEW**: Load token via `LoadTokenFor(resolvedEmail)` instead of `LoadToken()`
   - If token not found (os.ErrNotExist), return error: "no token for account %s. Run 'gsuite login' to authenticate"
6. Create OAuth2Config and Gmail service from token (same as before)
7. Return service

This is a breaking signature change — all callers will be updated in plan 11-04. For now, update the function and fix the two internal callers (if any).
  </action>
  <verify>go build -o gsuite . — may fail until plan 11-04 updates callers. Verify the auth package compiles: go build ./internal/auth/</verify>
  <done>NewGmailService takes account parameter, resolves via AccountStore, loads per-account token. Migration runs automatically on first call.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `go build ./internal/auth/` compiles the auth package
- [ ] MigrateIfNeeded handles: no legacy token, legacy token present, already migrated
- [ ] Login() creates per-account token and updates account store
- [ ] NewGmailService() resolves account from parameter or store
</verification>

<success_criteria>
- Migration logic transparently upgrades single-token to multi-account
- Login adds accounts to the store
- NewGmailService resolves the correct account's token
- Auth package compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/11-multi-account/11-02-SUMMARY.md`
</output>
