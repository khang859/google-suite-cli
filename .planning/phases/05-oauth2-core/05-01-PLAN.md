---
phase: 05-oauth2-core
plan: 01
type: execute
depends_on: []
files_modified: [internal/auth/token.go, internal/auth/oauth2.go]
---

<objective>
Implement OAuth2 authorization code flow with PKCE for personal Gmail accounts, including file-based token storage and automatic browser-based login.

Purpose: Enable personal Gmail users (non-workspace) to authenticate without service accounts, using browser-based OAuth2 consent flow.
Output: Two new files in internal/auth/ providing token persistence and OAuth2 PKCE flow that produce an authenticated *gmail.Service.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/auth/auth.go
@cmd/root.go
@go.mod

**Tech stack available:** Go 1.24, golang.org/x/oauth2 (already in go.mod), google.golang.org/api/gmail/v1
**Established patterns:** auth.Config struct + auth.NewGmailService() returns *gmail.Service; all commands use "me" as userId
**Constraining decisions:**
- Service account flow must remain untouched (Phase 6 handles dispatch)
- OAuth2 scope should match existing GmailModifyScope
- Token stored at ~/.config/gsuite/token.json (XDG-compatible)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create token storage module</name>
  <files>internal/auth/token.go</files>
  <action>
Create internal/auth/token.go with file-based OAuth2 token persistence.

Functions to implement:
- `TokenPath() string` — returns ~/.config/gsuite/token.json (use os.UserConfigDir(), fallback to $HOME/.config). Create parent directories with 0700 permissions if they don't exist.
- `SaveToken(token *oauth2.Token) error` — serialize token to JSON, write to TokenPath() with 0600 permissions. Include access_token, refresh_token, token_type, expiry.
- `LoadToken() (*oauth2.Token, error)` — read TokenPath(), deserialize JSON into oauth2.Token. Return os.ErrNotExist style error if file missing (don't wrap — let callers use errors.Is).

Use golang.org/x/oauth2 Token type directly — no custom struct. The oauth2 package handles JSON marshaling natively.

Do NOT store client_id/client_secret in the token file — only the token itself.
  </action>
  <verify>go build ./internal/auth/ compiles without errors</verify>
  <done>token.go exists with TokenPath, SaveToken, LoadToken functions. go vet ./internal/auth/ passes clean.</done>
</task>

<task type="auto">
  <name>Task 2: Create OAuth2 PKCE authorization flow</name>
  <files>internal/auth/oauth2.go</files>
  <action>
Create internal/auth/oauth2.go implementing browser-based OAuth2 authorization code flow with PKCE.

**OAuth2Config struct:**
- ClientID, ClientSecret string (from OAuth2 client JSON)
- Hold an oauth2.Config internally with:
  - Endpoint: google.Endpoint (from golang.org/x/oauth2/google)
  - RedirectURL: "http://localhost:8089/callback"
  - Scopes: []string{gmail.GmailModifyScope}

**Functions to implement:**

1. `NewOAuth2Config(clientID, clientSecret string) *OAuth2Config` — constructor that builds the internal oauth2.Config.

2. `(c *OAuth2Config) Authenticate(ctx context.Context) (*oauth2.Token, error)` — orchestrates the full flow:
   a. Generate PKCE code_verifier (32 random bytes, base64url-encoded, no padding) and code_challenge (SHA256 of verifier, base64url-encoded, no padding).
   b. Generate random state parameter (16 bytes, hex-encoded).
   c. Build authorization URL with: oauth2.AccessTypeOffline, oauth2.SetAuthURLParam("code_challenge", challenge), oauth2.SetAuthURLParam("code_challenge_method", "S256"), oauth2.SetAuthURLParam("prompt", "consent") to force refresh token.
   d. Start local HTTP server on :8089 with a single handler at /callback.
   e. Print the auth URL and attempt to open it in browser using exec.Command (try xdg-open, open, then fallback to printing URL only).
   f. The /callback handler: extract "code" and "state" query params, validate state matches, send code to a channel, respond with HTML "Authentication successful! You can close this tab."
   g. Wait for code from channel (with 2-minute timeout via context.WithTimeout).
   h. Exchange code for token using oauth2.SetAuthURLParam("code_verifier", verifier).
   i. Shut down the HTTP server.
   j. Return the token.

3. `(c *OAuth2Config) NewGmailService(ctx context.Context, token *oauth2.Token) (*gmail.Service, error)` — creates gmail.Service from existing token:
   a. Create token source with c.config.TokenSource(ctx, token).
   b. Create HTTP client with oauth2.NewClient(ctx, tokenSource).
   c. Return gmail.NewService(ctx, option.WithHTTPClient(client)).

**Error handling:** Return clear errors for: server start failure, timeout waiting for callback, state mismatch, token exchange failure. Use fmt.Errorf with %w wrapping.

**Do NOT** use InsecureSkipVerify or disable any TLS verification. Do NOT hardcode any client IDs — they come from parameters.
  </action>
  <verify>go build ./internal/auth/ compiles without errors; go vet ./internal/auth/ passes clean</verify>
  <done>oauth2.go exists with OAuth2Config, Authenticate (PKCE flow with local server + browser open), and NewGmailService. Full build passes.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go vet ./...` passes clean
- [ ] internal/auth/token.go has TokenPath, SaveToken, LoadToken
- [ ] internal/auth/oauth2.go has OAuth2Config, Authenticate (PKCE), NewGmailService
- [ ] No hardcoded credentials or client IDs
- [ ] Token file permissions are 0600, directory permissions 0700
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No new build errors or warnings
- OAuth2 PKCE flow is fully implemented (token storage + browser auth + Gmail service creation)
- Existing service account auth in auth.go is untouched
</success_criteria>

<output>
After completion, create `.planning/phases/05-oauth2-core/05-01-SUMMARY.md`
</output>
