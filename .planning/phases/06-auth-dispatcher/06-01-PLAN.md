---
phase: 06-auth-dispatcher
plan: 01
type: execute
depends_on: []
files_modified: [internal/auth/auth.go]
---

<objective>
Refactor auth.go to auto-detect credential type from JSON and dispatch to service account or OAuth2 flow.

Purpose: Enable a single `NewGmailService()` entry point that transparently handles both service account (domain-wide delegation) and OAuth2 (personal Gmail) credentials, so existing commands work unchanged.
Output: Updated `internal/auth/auth.go` with credential type detection and dual-path dispatch.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-oauth2-core/05-01-SUMMARY.md

# Key source files:
@internal/auth/auth.go
@internal/auth/oauth2.go
@internal/auth/token.go
@cmd/root.go

**Tech stack available:** Go, Cobra, golang.org/x/oauth2, google.golang.org/api/gmail/v1
**Established patterns:** OAuth2Config struct, PKCE flow, token persistence at ~/.config/gsuite/token.json
**Constraining decisions:**
- Phase 5: OAuth2Config uses NewOAuth2Config(clientID, clientSecret) and separate NewGmailService method
- Phase 5: Token stored via SaveToken/LoadToken at XDG-compatible path
- v1.0: All commands call auth.NewGmailService(ctx, auth.Config{...}) — this signature is the integration point
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add credential type detection to auth.go</name>
  <files>internal/auth/auth.go</files>
  <action>
Add a credential type detection function to auth.go that parses loaded JSON and determines which auth flow to use.

**Detection logic:** Parse JSON into a map[string]interface{} and check:
- If key `"type"` == `"service_account"` → service account flow (existing path)
- If key `"installed"` exists → OAuth2 client credentials (desktop app). Extract `client_id` and `client_secret` from `json["installed"].(map)["client_id"]` and `json["installed"].(map)["client_secret"]`.
- If key `"web"` exists → OAuth2 client credentials (web app). Extract same from `json["web"]`.
- Otherwise → return error with helpful message listing expected formats.

Add a `detectCredentialType` function:
```
type credentialType int
const (
    credServiceAccount credentialType = iota
    credOAuth2Client
)

func detectCredentialType(jsonData []byte) (credentialType, error)
```

And an `extractOAuth2ClientCreds` function:
```
func extractOAuth2ClientCreds(jsonData []byte) (clientID, clientSecret string, err error)
```
This parses the "installed" or "web" key and extracts client_id + client_secret.

**What to avoid:** Don't change the existing `Config` struct or `LoadCredentials` function — they stay as-is for service account compatibility. Don't add new dependencies.
  </action>
  <verify>go build ./internal/auth/ compiles without errors</verify>
  <done>detectCredentialType correctly identifies service_account, installed, and web JSON types. extractOAuth2ClientCreds extracts client_id and client_secret from either installed or web key.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor NewGmailService to dispatch between auth flows</name>
  <files>internal/auth/auth.go</files>
  <action>
Modify the existing `NewGmailService` function to:

1. Load credentials JSON via existing `LoadCredentials(cfg)`.
2. Call `detectCredentialType(credJSON)` to determine the flow.
3. **If service account:** Continue with existing JWT logic (unchanged behavior). Still requires `cfg.UserEmail`.
4. **If OAuth2 client:**
   - Extract client_id/client_secret via `extractOAuth2ClientCreds(credJSON)`.
   - Call `LoadToken()` to check for a cached token.
   - If token exists: create `NewOAuth2Config(clientID, clientSecret)` and call its `NewGmailService(ctx, token)`.
   - If token does NOT exist (os.ErrNotExist): return a clear error saying "No OAuth2 token found. Run 'gsuite login' first to authenticate." Do NOT auto-trigger the browser flow from NewGmailService — that's Phase 7's `login` command responsibility.
   - `cfg.UserEmail` is NOT required for OAuth2 path (the token is for the logged-in user). If `cfg.UserEmail` is empty, proceed. If set, ignore it silently (OAuth2 uses "me" which resolves to the token owner).

**Key:** The function signature `NewGmailService(ctx context.Context, cfg Config) (*gmail.Service, error)` stays identical. All existing callers continue working without changes.

Move the existing service-account-specific logic into a private helper `newServiceAccountGmailService(ctx, cfg, credJSON)` for clarity.
  </action>
  <verify>go build ./... compiles without errors. The binary runs: ./gsuite --help still works.</verify>
  <done>NewGmailService dispatches to service account path when given service_account JSON and to OAuth2 path when given client credentials JSON. Existing commands are unaffected (they pass service account creds as before). OAuth2 path returns helpful "run gsuite login" error when no token cached.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go vet ./...` passes
- [ ] `./gsuite --help` still works
- [ ] `./gsuite whoami --user test@example.com` fails with expected auth error (no real credentials), NOT a crash
- [ ] No changes to any files in cmd/ — all commands remain untouched
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No changes to cmd/ package — existing CLI unchanged
- NewGmailService correctly dispatches based on credential JSON type
- Service account flow is identical to pre-refactor behavior
- OAuth2 flow loads cached token or returns actionable error
- Phase 6 complete
</success_criteria>

<output>
After completion, create `.planning/phases/06-auth-dispatcher/06-01-SUMMARY.md`
</output>
