---
phase: 08-device-auth-flow
plan: 01
type: execute
depends_on: []
files_modified: [internal/auth/oauth2.go, internal/auth/auth.go, cmd/login.go]
---

<objective>
Add `--no-browser` flag to `gsuite login` using RFC 8628 device authorization flow for headless environments (EC2, SSH, containers).

Purpose: Enable OAuth2 login on machines without a browser by displaying a URL + code that the user enters on any device.
Output: Working `gsuite login --no-browser` that authenticates via device flow and saves token identically to browser flow.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (OAuth2 implementation):
@.planning/phases/05-oauth2-core/05-01-SUMMARY.md
@.planning/phases/07-cli-integration/07-01-SUMMARY.md

# Source files being modified:
@internal/auth/oauth2.go
@internal/auth/auth.go
@cmd/login.go

**Tech stack available:** golang.org/x/oauth2 v0.34.0 (has built-in RFC 8628 device flow: Config.DeviceAuth, Config.DeviceAccessToken)
**Established patterns:** OAuth2Config struct wraps oauth2.Config; auth.Login() encapsulates full flow; token saved via SaveToken()
**Constraining decisions:**
- [Phase 5]: OAuth2Config wraps oauth2.Config with NewOAuth2Config constructor
- [Phase 6]: auth.Login() validates cred type, runs flow, saves token, returns email
- [Phase 7]: cmd/login.go calls auth.Login(ctx, credJSON) and prints email

**Key discovery (Level 1):**
- `google.Endpoint` already has `DeviceAuthURL: "https://oauth2.googleapis.com/device/code"` — no custom endpoint needed
- `Config.DeviceAuth(ctx)` returns `DeviceAuthResponse{UserCode, VerificationURI, VerificationURIComplete}`
- `Config.DeviceAccessToken(ctx, da)` polls with automatic interval backoff until user completes auth or code expires
- The oauth2.Config used by OAuth2Config already uses `google.Endpoint`, so device flow works out of the box
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DeviceAuthenticate method to OAuth2Config</name>
  <files>internal/auth/oauth2.go</files>
  <action>
Add a `DeviceAuthenticate` method on `*OAuth2Config` that performs the RFC 8628 device authorization flow:

1. Call `c.config.DeviceAuth(ctx)` to get a `DeviceAuthResponse` with user code and verification URL
2. Print the verification URL and user code to stderr (not stdout — keeps output scriptable):
   - Format: "Visit: {VerificationURI}" / "Enter code: {UserCode}"
   - If `VerificationURIComplete` is non-empty, also print: "Or visit: {VerificationURIComplete}"
3. Call `c.config.DeviceAccessToken(ctx, da)` to poll for the token (library handles interval/backoff/expiry)
4. Return the `*oauth2.Token` or error

Use `fmt.Fprintf(os.Stderr, ...)` for user-facing output (not stdout) to keep JSON output clean if ever piped. Do NOT add a custom polling loop — the oauth2 library's DeviceAccessToken handles RFC 8628 polling semantics including slow_down backoff.
  </action>
  <verify>go build -o gsuite . succeeds without errors</verify>
  <done>DeviceAuthenticate method exists on OAuth2Config, compiles cleanly, uses stdlib device flow</done>
</task>

<task type="auto">
  <name>Task 2: Wire --no-browser flag through Login and CLI</name>
  <files>internal/auth/auth.go, cmd/login.go</files>
  <action>
**In internal/auth/auth.go:**
- Add `noBrowser bool` parameter to `Login()` function: `Login(ctx context.Context, credJSON []byte, noBrowser bool) (string, error)`
- After creating `oauthCfg`, branch on `noBrowser`:
  - If true: call `oauthCfg.DeviceAuthenticate(ctx)` instead of `oauthCfg.Authenticate(ctx)`
  - If false: existing `oauthCfg.Authenticate(ctx)` path (unchanged)
- Rest of Login (SaveToken, get profile, return email) stays identical for both paths

**In cmd/login.go:**
- Add a `--no-browser` bool flag on `loginCmd` (local flag, not persistent): `loginCmd.Flags().BoolVar(&noBrowser, "no-browser", false, "Use device authorization flow for headless environments")`
- Pass the flag value to `auth.Login(ctx, credJSON, noBrowser)`
- Update the Long description to mention `--no-browser` for headless use
- Add an example: `gsuite login --no-browser  # For SSH/headless environments`
  </action>
  <verify>go build -o gsuite . && ./gsuite login --help shows --no-browser flag with description</verify>
  <done>--no-browser flag appears in help, Login() accepts noBrowser param, build succeeds</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `go build -o gsuite .` succeeds without errors
- [ ] `./gsuite login --help` shows `--no-browser` flag
- [ ] `go vet ./...` passes
- [ ] Code follows existing patterns (OAuth2Config method, auth.Login encapsulation)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No build errors or warnings
- `gsuite login --no-browser` initiates device flow (prints URL + code, polls for token)
- `gsuite login` (without flag) still works via browser flow (no regression)
- Token saved identically regardless of flow used
- Phase 8 complete — v1.2 milestone shipped
</success_criteria>

<output>
After completion, create `.planning/phases/08-device-auth-flow/08-01-SUMMARY.md`
</output>
